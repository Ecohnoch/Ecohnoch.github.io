---
layout: post
title:  "独立开发Micro C编译器-语法分析"
date:   2017-06-29
categories: 算法与数学
excerpt: 嗯
---

<p>这一段时间向老师要了一个project，用C++开发一个Micro C编译器，
并且把编译器的每一个部分都做成可视化的，这样还能够起到一个教学的作用。</p>

<p>于是就开始写这个编译器了嘛，不过不准备把里面每一个步骤都在博文里面说的很详细。编译原理是一门
门槛很高的科目，花太多时间放在教学和其他的方面会妨碍到我的正常的学习步伐。于是这几篇博文更多
的就是描述我写这个编译器的过程吧，而不是原理和语言教学。
原理的话，更多的需要看看书，把这门课学好。所以这些博文更适合有一定基础的人，并且想做些什么的同学看。</p>

<p>233，对我来说相当于重构一遍上机题吧。</p>

<p>嗯，我现在处于四个project并行进行...嗯...原谅我话变少了。</p>

<h1>语法分析部分</h1>

<p>还没有写完，一大半差不多已经完成。</p>

<h2>定义类型</h2>

<p>基本类型和布尔类型的分析元素。</p>

<p>基本类型中就包括【状态，符号】</p>

<p>布尔类型中包括【状态，符号，属性值，翻译值】</p>

<p><code>
class basicElement{
public:
    basicElement(int s, string sim): state(s), simbol(sim){}
    int state;
    string simbol;
    void set(int s, string sim){state = s; simbol = sim;}
    void show(){cout&lt;&lt;&quot;state: &quot;&lt;&lt;state&lt;&lt;&quot; simbol:&quot;&lt;&lt;simbol&lt;&lt;endl;}
};
class boolElement{
public:
    boolElement(int s, string sim, bool v, int i = 0): state(s), simbol(sim), val(v), id(i){}
    int state;
    string simbol;
    int id;
    bool val;
    void set(int s, string sim, bool v, int i = 0){state = s; simbol = sim; val = v; id = i;}
    void show(){cout&lt;&lt;&quot;state: &quot;&lt;&lt;state&lt;&lt;&quot; simbol:&quot;&lt;&lt;simbol&lt;&lt;&quot; val: &quot;&lt;&lt;val&lt;&lt;&quot; id: &quot;&lt;&lt;id&lt;&lt;endl;}
};
</code></p>

<h2>SLR(0)分析表</h2>

<p>有三张表，分别代表着：</p>

<ul><li>控制语句，if--else，while-- 。</li><li>布尔语句，进行布尔运算的语句。</li><li>计算语句，进行计算的语句。</li></ul>

<p>三种语句的产生式分别如下：</p>

<p><code>
    100  S&#39; -&gt; S
    101  S  -&gt; if e S else S
    102  S  -&gt; while e S
    103  S  -&gt; {L}
    104  S  -&gt; a;
    105  L  -&gt; S
    106  L  -&gt; SL
</code>
<code>
    100 : S&#39;  -&gt;  E
    101 : E   -&gt;  E + E
    102 : E   -&gt;  E * E
    103 : E   -&gt;  (E)
    104 : E   -&gt;  i
</code>
<code>
    100: S&#39;  -&gt;  B
    101: B   -&gt;  i
    102: B   -&gt;  i rop i
    103: B   -&gt;  (B)
    104: B   -&gt;  !B
    105: A   -&gt;  B&amp;&amp;
    106: B   -&gt;  AB
    107: O   -&gt;  B||
    108: B   -&gt;  OB
</code></p>

<p>根据产生式得到，三张SLR(0)分析表，用Table类型进行封装：</p>

<p><code></code>`
class Table{
public:
    Table(){
        initColumn1(column1);
        initColumn2(column2);
        initColumn3(column3);
    }</p>

<pre><code>void initColumn1(map&lt;string, int&gt; &amp;c1);
void initColumn2(map&lt;string, int&gt; &amp;c2);
void initColumn3(map&lt;string, int&gt; &amp;c3);

int action[20][11]=
/* 0 */{{   2, -1,  3,  4, -1,  5, -1, -1, -1,  1, -1},
/* 1 */ {  -1, -1, -1, -1, -1, -1, -1, -1,100, -1, -1},
/* 2 */ {  -1, -1, -1, -1, -1, -1, -1,  6, -1, -1, -1},
/* 3 */ {  -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1},
/* 4 */ {   2, -1,  3,  4, -1,  5, -1, -1, -1,  9,  8},
/* 5 */ {  -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1},
/* 6 */ {   2, -1,  3,  4, -1,  5, -1, -1, -1, 11, -1},
/* 7 */ {   2, -1,  3,  4, -1,  5, -1, -1, -1, 12, -1},
/* 8 */ {  -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1},
/* 9 */ {  2, -1, 3, 4,105, 5, -1, -1, 105,  9, 14},
/* 10*/ {  104,104, 104, 104,104, 104, -1, -1,104, -1, -1},
/* 11*/ {  -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1},
/* 12*/ {  102,102, 102, 102, 102, 102, -1, -1,102, -1, -1},
/* 13*/ {  103,103, 103, 103,103, 103, -1, -1,103, -1, -1},
/* 14*/ {  106,106, 106, 106,106, 106, -1, -1, 106, -1, -1},
/* 15*/ {   2, -1,  3,  4, -1,  5, -1, -1, -1, 16, -1},
/* 16*/ {  101,101, 101, 101,101, 101, -1, -1,101, -1, -1}};
map&lt;string, int&gt; column1;

int action1[10][7]=
/* 0 */  {{  3, -1, -1,  2, -1, -1,  1},
/* 1 */   { -1,  4,  5, -1, -1,100, -1},
/* 2 */   {  3, -1, -1,  2, -1, -1,  6},
/* 3 */   { -1,104,104, -1,104,104, -1},
/* 4 */   {  3, -1, -1,  2, -1, -1,  7},
/* 5 */   {  3, -1, -1,  2, -1, -1,  8},
/* 6 */   { -1,  4,  5, -1,  9, -1, -1},
/* 7 */   { -1,101,  5, -1,101,101, -1},
/* 8 */   { -1,102,102, -1,102,102, -1},
/* 9 */   { -1,103,103, -1,103,103, -1}};
map&lt;string, int&gt; column2;

int action2[16][11]=
/* 0 */  {{  1, -1,  4, -1,  5, -1, -1, -1, 13,  7,  8},
/* 1 */   {  1,  2, -1,101, -1,101,101,101, -1, -1, -1},
/* 2 */   {  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
/* 3 */   { -1, -1, -1,102, -1,102,102,102, -1, -1, -1},
/* 4 */   {  1, -1,  4, -1,  5, -1, -1, -1, 11,  7,  8},
/* 5 */   {  1, -1,  4, -1,  5, -1, -1, -1,  6,  7,  8},
/* 6 */   { -1, -1, -1,104, -1,  9, 10,104, -1, -1, -1},
/* 7 */   {  1, -1,  4, -1,  5, -1, -1, -1, 14,  7,  8},
/* 8 */   {  1, -1,  4, -1,  5, -1, -1, -1, 15,  7,  8},
/* 9 */   {105, -1,105, -1,105, -1, -1, -1, -1, -1, -1},
/*10 */   {107, -1,107, -1,107, -1, -1, -1, -1, -1, -1},
/*11 */   { -1, -1, -1, 12, -1,  9, 10, -1, -1, -1, -1},
/*12 */   { -1, -1, -1,103, -1,103,103,103, -1, -1, -1},
/*13 */   { -1, -1, -1, -1, -1,  9, 10,100, -1, -1, -1},
/*14 */   { -1, -1, -1,106, -1,  9, 10,106, -1, -1, -1},
/*15 */   { -1, -1, -1,108, -1,  9, 10,108, -1, -1, -1}};
map&lt;string, int&gt; column3;</code></pre>

<p>};
<code></code>`</p>

<h2>语法分析类</h2>

<p><code></code>`
class grammar<em>parser{
public:
    grammar</em>parser();</p>

<pre><code>void test();
vector&lt;tokens&gt; test1();
vector&lt;tokens&gt; test2();
vector&lt;tokens&gt; test3();
vector&lt;tokens&gt; testControlStatement();
vector&lt;tokens&gt; testBoolStatement();

void parserControlStatement(vector&lt;tokens&gt; testStr);
void parserCalculateStatement(vector&lt;tokens&gt; testStr);
bool parserBoolStatement(vector&lt;tokens&gt; testStr);

vector&lt;tokens&gt; getControlStatement(vector&lt;tokens&gt; tokenFlow);
vector&lt;tokens&gt; getCalculateStatement(vector&lt;tokens&gt; tokenFlow);
vector&lt;tokens&gt; getBoolStatement(vector&lt;tokens&gt; tokenFlow);

vector&lt;string&gt; outputControlZhan;
vector&lt;string&gt; outputControlSimbols;
vector&lt;int&gt;    outputControlAction;
vector&lt;string&gt; outputControlInstruction;</code></pre>

<p>};
<code></code>`
解释：</p>

<p>test开头的都是测试，这个不用解释，都是测试下面定义的函数。</p>

<blockquote><p>void parserControlStatement(vector&lt;tokens&gt; testStr);</p></blockquote>

<p>对控制语句进行移进归约分析，SLR表中的第一个表驱动，传入的参数必须符合第一个表的产生式的记号流，示例可以看test1()返回的记号流。</p>

<p>注意：传入的记号流必须符合产生式，这个记号流并不能用词法分析得到的结果直接进行，需要一个中间操作，即getControlStatement(vector&lt;tokens&gt; testStr)</p>

<blockquote><p>void parserCalculateStatement(vector&lt;tokens&gt; testStr);</p></blockquote>

<p>对计算语句进行移进归约分析，解释如上。驱动的SLR表是第二个。示例记号流是test2()的返回值。</p>

<blockquote><p>bool parserBoolStatement(vector&lt;tokens&gt; testStr);</p></blockquote>

<p>对布尔语句进行移进归约分析，并且进行了语法制导翻译，返回了一个计算后的结果，true或者false。示例记号流是testBoolStatement(), 并不是test3()，因为test3()是进行语法判断的记号流，而我已经完成了语法制导翻译，所以用第三个。</p>

<blockquote><p>vector&lt;tokens&gt; getControlStatement(vector&lt;tokens&gt; tokenFlow);</p></blockquote>

<p>从词法分析器的记号流中，分离出控制语句，布尔语句，和计算语句，这个函数的功能还没有彻底完成，目前只能分离控制语句和布尔语句，计算语句并没有分析。</p>

<blockquote><p>vector&lt;tokens&gt; getCalculateStatement(vector&lt;tokens&gt; tokenFlow);</p></blockquote>

<p>未完成。</p>

<blockquote><p>vector&lt;tokens&gt; getBoolStatement(vector&lt;tokens&gt; tokenFlow);</p></blockquote>

<p>未完成。</p>

<blockquote><p>vector&lt;string&gt; outputControlZhan;</p></blockquote>

<p>向UI程序中传入控制语句的移进归约栈表。</p>

<blockquote><p>vector&lt;string&gt; outputControlSimbols;</p></blockquote>

<p>向UI程序中传入控制语句的分析剩余符号。</p>

<blockquote><p>vector&lt;int&gt;    outputControlAction;</p></blockquote>

<p>向UI程序中传入控制语句的动作，即当前状态值。</p>

<blockquote><p>vector&lt;string&gt; outputControlInstruction;</p></blockquote>

<p>向UI程序中传入当前状态的说明。比如是移进，还是归约。</p>

<h2>项目进度</h2>

<p>编译器前端：</p>

<pre><code>1. 词法分析完成，未写单元测试，未将符号表写清楚。
2. 语法分析完成了大部分，未完成错误恢复，未完成计算语句部分的内容。
3. 语法制导翻译只完成了布尔语句的计算，其他未完成。
4. 语义分析未开始
5. 中间代码生成未开始</code></pre>

<p>编译器后端：</p>

<pre><code>1. 未开始</code></pre>

<p>UI：</p>

<pre><code>1. 基本UI界面搭好，未优化
2. 能够显示正常的词法分析和语法分析，三种语句均可分析并显示。
3. 字体优化，界面大小优化，界面颜色优化，界面布局优化，界面控件优化均未开始。</code></pre>

<p>目前代码行数：1.5k左右</p>

<p>记录日期：2017年6月29日</p>

<p>项目位置：我的Github中</p>