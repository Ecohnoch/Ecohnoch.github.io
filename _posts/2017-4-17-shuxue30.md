---
layout: post
title:  "计算机网络Computer Networking(八、传输层复习(第二部分))"
date:   2017-04-17
categories: 算法与数学
excerpt: 嗯
---

参考来源：原创

# 可靠传输状态机

其实这个破玩意超级简单，但是为什么书上的图要搞的那么复杂。

大概是要维护一个成绩的正态分布吧（笑。

### rdt 1.0

特点：基于可靠信道。

过程：A给B直接发送包，B直接收到包，不会有任何问题。

### rdt 2.0

特点：信道不可靠，包可能损坏，导入了ACK机制

过程：A给B直接发送包，等待B发回ACK后才继续发包，B接收包，收到了就发ACK，收到了坏的包就发NAK

### rdt 2.1

特点：不可靠信道，ACK本身可能损坏，导入了序号机制

过程：A给B发送包，标记包为0，等待B发回ACK后就发标记为1的包，如此继续。B也维护一个变量，为0的时候收到标记为0的包，才会发ACK，为1的时候收到标记为1的包，才会发ACK。

### rdt 2.2

特点：将包的标记直接放到ACK当中

过程：A给B发送包，必须轮流收到ACK0和ACK1才能正常发包，否则重传。B也是，维护一个分组序号，由ACK报文实现。

### rdt 3.0

特点：最终版，没有什么问题，引入了超时重传机制。

四种过程：

#### 正常

A给B发送pkt0, B收到后给A发送ACK0，A收到后给B发送pkt1，B收到后给A发送ACK1...

#### 丢包

A给B发送pkt0, B收到后给A发送ACK0，A收到后给B发送pkt1

pkt1丢失了，A等待ACK1，未果。

于是超时了，A重传。

#### 丢失ACK

A给B发送pkt0, B收到后给A发送ACK0，ACK0丢失，A等待ACK0，未果。

于是超时了，A重传pkt0, B收到了重复了的pkt0, 冗余机制打开，把多的扔掉，返回ACK0

#### 过早就开始超时重传

A给B发送pkt0, B收到后给A发送ACK0，A给B发送pkt1, 还没等B发回ACK1，A就超时重传了。

这样B收到了第一个pkt1, 返回ACK1， 又收到了pkt1, 冗余机制开启，扔掉多余的，还是返回ACK1

A接受到了第一个ACK1，发送pkt2, A接收到了第二个ACK1，什么都不做。

到此结束了。

# 流量控制

这个东西也很简单，就是不知道考到什么程度，先写一个最简单的，到时候看需不需要补充。

> 引入原因： 防止发送方过快的发送数据使接收方缓存溢出，比如应用程序处理数据过慢的时候，容易发生这样的事。

> 怎么解决：TCP让发送方维护一个【接受窗口】的东西来提供流量控制服务。

> 接受窗口是什么：给发送方一个指示，即接收方还有多少可以用的缓存空间，由于TCP是全双工通信，所以双方都要各自维护一个【接受窗口】

接收窗口：

![image](http://i4.buimg.com/1949/0233f958a8341790.png)

rwnd = RcvBuffer - (LastByteRcved - LastByteRead)

实现流程：

1. 主机A给主机B发送数据
2. 主机B通知主机A，还有多少可用空间(rwnd)
3. 主机A轮流跟踪两个变量(LastByteSend, LastByteAcked)
4. 要保证LastByteSent - LastByteAcked = rwnd
5. 当B的接收窗口为0时，A继续不停的发送一个字节的报文段去试探，直到确认B有了一个非空的rwnd为止

# 拥塞控制原理

拥塞控制算法：慢开始，拥塞避免，快重传，快恢复

[这一篇文章讲得非常的好，我将会引用在本文](https://wenku.baidu.com/view/d93687f64028915f804dc245.html)

### 慢开始

1. 主机开始发送数据的时候，如果直接发送很大的数据，可能GG
2. 先慢慢试探，从小达大发送拥塞窗口数值
3. 刚开始可以将cwnd设为MSS的值，然后每次都翻倍
4. 为了防止cwnd增长引起拥塞，设置一个慢开始门限，ssthresh

### 具体过程

1. TCP连接初始化，拥塞窗口为1
2. 执行慢开始算法，cwnd按2^n的指数型递增
3. 直到cwnd == ssthresh的时候，开始执行拥塞避免算法，线性增长
4. 当网络发生了拥塞，那么ssthresh设置为开始的一半或者某个数值，cwnd重新设置为1，按步骤2继续执行

如下图：

![image](http://i4.buimg.com/1949/45e5815a2ee7b441.png)


### 快重传和快恢复

一条TCP连接有时候会因为等待重传计时器的超时而空闲较长时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复。

快重传：在某些情况下更早重传丢失的报文段（比如当连续收到三个ACK的时候）

如下图:

![image](http://i4.buimg.com/1949/6bfe575180473dc9.png)



