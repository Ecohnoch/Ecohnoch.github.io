---
layout: post
title:  "独立开发Micro C编译器，语法分析"
date:   2017-06-20
categories: 算法与数学
excerpt: 嗯
---

这一段时间向老师要了一个project，用C++开发一个Micro C编译器，
并且把编译器的每一个部分都做成可视化的，这样还能够起到一个教学的作用。

于是就开始写这个编译器了嘛，不过不准备把里面每一个步骤都在博文里面说的很详细。编译原理是一门
门槛很高的科目，花太多时间放在教学和其他的方面会妨碍到我的正常的学习步伐。于是这几篇博文更多
的就是描述我写这个编译器的过程吧，而不是原理和语言教学。
原理的话，更多的需要看看书，把这门课学好。所以这些博文更适合有一定基础的人，并且想做些什么的同学看。

233，对我来说相当于重构一遍上机题吧。

嗯，我现在处于四个project并行进行...嗯...原谅我话变少了。
# 语法分析部分

还没有写完，一大半差不多已经完成。

## 定义类型

基本类型和布尔类型的分析元素。

基本类型中就包括【状态，符号】

布尔类型中包括【状态，符号，属性值，翻译值】

```
class basicElement{
public:
    basicElement(int s, string sim): state(s), simbol(sim){}
    int state;
    string simbol;
    void set(int s, string sim){state = s; simbol = sim;}
    void show(){cout<<"state: "<<state<<" simbol:"<<simbol<<endl;}
};
class boolElement{
public:
    boolElement(int s, string sim, bool v, int i = 0): state(s), simbol(sim), val(v), id(i){}
    int state;
    string simbol;
    int id;
    bool val;
    void set(int s, string sim, bool v, int i = 0){state = s; simbol = sim; val = v; id = i;}
    void show(){cout<<"state: "<<state<<" simbol:"<<simbol<<" val: "<<val<<" id: "<<id<<endl;}
};
```

## SLR(0)分析表

有三张表，分别代表着：

* 控制语句，if--else，while-- 。
* 布尔语句，进行布尔运算的语句。
* 计算语句，进行计算的语句。

三种语句的产生式分别如下：

```
    100  S' -> S
    101  S  -> if e S else S
    102  S  -> while e S
    103  S  -> {L}
    104  S  -> a;
    105  L  -> S
    106  L  -> SL
```
```
    100 : S'  ->  E
    101 : E   ->  E + E
    102 : E   ->  E * E
    103 : E   ->  (E)
    104 : E   ->  i
```
```
    100: S'  ->  B
    101: B   ->  i
    102: B   ->  i rop i
    103: B   ->  (B)
    104: B   ->  !B
    105: A   ->  B&&
    106: B   ->  AB
    107: O   ->  B||
    108: B   ->  OB
```

根据产生式得到，三张SLR(0)分析表，用Table类型进行封装：

```
class Table{
public:
    Table(){
        initColumn1(column1);
        initColumn2(column2);
        initColumn3(column3);
    }

    void initColumn1(map<string, int> &c1);
    void initColumn2(map<string, int> &c2);
    void initColumn3(map<string, int> &c3);

    int action[20][11]=
    /* 0 */{{   2, -1,  3,  4, -1,  5, -1, -1, -1,  1, -1},
    /* 1 */ {  -1, -1, -1, -1, -1, -1, -1, -1,100, -1, -1},
    /* 2 */ {  -1, -1, -1, -1, -1, -1, -1,  6, -1, -1, -1},
    /* 3 */ {  -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1},
    /* 4 */ {   2, -1,  3,  4, -1,  5, -1, -1, -1,  9,  8},
    /* 5 */ {  -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1},
    /* 6 */ {   2, -1,  3,  4, -1,  5, -1, -1, -1, 11, -1},
    /* 7 */ {   2, -1,  3,  4, -1,  5, -1, -1, -1, 12, -1},
    /* 8 */ {  -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1},
    /* 9 */ {  2, -1, 3, 4,105, 5, -1, -1, 105,  9, 14},
    /* 10*/ {  104,104, 104, 104,104, 104, -1, -1,104, -1, -1},
    /* 11*/ {  -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    /* 12*/ {  102,102, 102, 102, 102, 102, -1, -1,102, -1, -1},
    /* 13*/ {  103,103, 103, 103,103, 103, -1, -1,103, -1, -1},
    /* 14*/ {  106,106, 106, 106,106, 106, -1, -1, 106, -1, -1},
    /* 15*/ {   2, -1,  3,  4, -1,  5, -1, -1, -1, 16, -1},
    /* 16*/ {  101,101, 101, 101,101, 101, -1, -1,101, -1, -1}};
    map<string, int> column1;

    int action1[10][7]=
    /* 0 */  {{  3, -1, -1,  2, -1, -1,  1},
    /* 1 */   { -1,  4,  5, -1, -1,100, -1},
    /* 2 */   {  3, -1, -1,  2, -1, -1,  6},
    /* 3 */   { -1,104,104, -1,104,104, -1},
    /* 4 */   {  3, -1, -1,  2, -1, -1,  7},
    /* 5 */   {  3, -1, -1,  2, -1, -1,  8},
    /* 6 */   { -1,  4,  5, -1,  9, -1, -1},
    /* 7 */   { -1,101,  5, -1,101,101, -1},
    /* 8 */   { -1,102,102, -1,102,102, -1},
    /* 9 */   { -1,103,103, -1,103,103, -1}};
    map<string, int> column2;

    int action2[16][11]=
    /* 0 */  {{  1, -1,  4, -1,  5, -1, -1, -1, 13,  7,  8},
    /* 1 */   {  1,  2, -1,101, -1,101,101,101, -1, -1, -1},
    /* 2 */   {  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    /* 3 */   { -1, -1, -1,102, -1,102,102,102, -1, -1, -1},
    /* 4 */   {  1, -1,  4, -1,  5, -1, -1, -1, 11,  7,  8},
    /* 5 */   {  1, -1,  4, -1,  5, -1, -1, -1,  6,  7,  8},
    /* 6 */   { -1, -1, -1,104, -1,  9, 10,104, -1, -1, -1},
    /* 7 */   {  1, -1,  4, -1,  5, -1, -1, -1, 14,  7,  8},
    /* 8 */   {  1, -1,  4, -1,  5, -1, -1, -1, 15,  7,  8},
    /* 9 */   {105, -1,105, -1,105, -1, -1, -1, -1, -1, -1},
    /*10 */   {107, -1,107, -1,107, -1, -1, -1, -1, -1, -1},
    /*11 */   { -1, -1, -1, 12, -1,  9, 10, -1, -1, -1, -1},
    /*12 */   { -1, -1, -1,103, -1,103,103,103, -1, -1, -1},
    /*13 */   { -1, -1, -1, -1, -1,  9, 10,100, -1, -1, -1},
    /*14 */   { -1, -1, -1,106, -1,  9, 10,106, -1, -1, -1},
    /*15 */   { -1, -1, -1,108, -1,  9, 10,108, -1, -1, -1}};
    map<string, int> column3;
};
```

## 语法分析类


```
class grammar_parser{
public:
    grammar_parser();

    void test();
    vector<tokens> test1();
    vector<tokens> test2();
    vector<tokens> test3();
    vector<tokens> testControlStatement();
    vector<tokens> testBoolStatement();

    void parserControlStatement(vector<tokens> testStr);
    void parserCalculateStatement(vector<tokens> testStr);
    bool parserBoolStatement(vector<tokens> testStr);

    vector<tokens> getControlStatement(vector<tokens> tokenFlow);
    vector<tokens> getCalculateStatement(vector<tokens> tokenFlow);
    vector<tokens> getBoolStatement(vector<tokens> tokenFlow);

    vector<string> outputControlZhan;
    vector<string> outputControlSimbols;
    vector<int>    outputControlAction;
    vector<string> outputControlInstruction;
};
```
解释：

test开头的都是测试，这个不用解释，都是测试下面定义的函数。

> void parserControlStatement(vector<tokens> testStr);

对控制语句进行移进归约分析，SLR表中的第一个表驱动，传入的参数必须符合第一个表的产生式的记号流，示例可以看test1()返回的记号流。

注意：传入的记号流必须符合产生式，这个记号流并不能用词法分析得到的结果直接进行，需要一个中间操作，即getControlStatement(vector<tokens> testStr)

> void parserCalculateStatement(vector<tokens> testStr);

对计算语句进行移进归约分析，解释如上。驱动的SLR表是第二个。示例记号流是test2()的返回值。

> bool parserBoolStatement(vector<tokens> testStr);

对布尔语句进行移进归约分析，并且进行了语法制导翻译，返回了一个计算后的结果，true或者false。示例记号流是testBoolStatement(), 并不是test3()，因为test3()是进行语法判断的记号流，而我已经完成了语法制导翻译，所以用第三个。

> vector<tokens> getControlStatement(vector<tokens> tokenFlow);

从词法分析器的记号流中，分离出控制语句，布尔语句，和计算语句，这个函数的功能还没有彻底完成，目前只能分离控制语句和布尔语句，计算语句并没有分析。

> vector<tokens> getCalculateStatement(vector<tokens> tokenFlow);

未完成。

> vector<tokens> getBoolStatement(vector<tokens> tokenFlow);

未完成。

> vector<string> outputControlZhan;

向UI程序中传入控制语句的移进归约栈表。

> vector<string> outputControlSimbols;

向UI程序中传入控制语句的分析剩余符号。

> vector<int>    outputControlAction;

向UI程序中传入控制语句的动作，即当前状态值。

> vector<string> outputControlInstruction;

向UI程序中传入当前状态的说明。比如是移进，还是归约。

## 项目进度

编译器前端：

    1. 词法分析完成，未写单元测试，未将符号表写清楚。
    2. 语法分析完成了大部分，未完成错误恢复，未完成计算语句部分的内容。
    3. 语法制导翻译只完成了布尔语句的计算，其他未完成。
    4. 语义分析未开始
    5. 中间代码生成未开始

编译器后端：

    1. 未开始

UI：

    1. 基本UI界面搭好，未优化
    2. 能够显示正常的词法分析和语法分析，三种语句均可分析并显示。
    3. 字体优化，界面大小优化，界面颜色优化，界面布局优化，界面控件优化均未开始。

目前代码行数：1.5k左右

记录日期：2017年6月29日

项目位置：我的Github中。
